			 POWERSHELL TUTORIAL SERIES

Playlist: https://www.youtube.com/watch?v=hXwVm3vC-10&list=PLAVSKeDM4AqN8zINh1niRxoZKqpd9FgtE&ab_channel=ABMedia

Powershell es extremadamente útil y poderosa.Está construida sobre .NET(C# también está built in top of .NET).
El autor recomienda bajarse la última versión desde el repo de GitHub(la 6) y no usar la 5 que es la que viene instalada por defecto.
Para ver la version tipear:
$PSVersionTable <- puedo ver que tengo la 5

El principal concepto a tener en cuenta es lo que devuelve PS.En otras lineas de commando como bash,cada comando devuelve una única cosa,texto.
Si hago un ls devolverá texto,esto es muy simple y útil,pero extremadamente limitante.

Powershell toma una aproximación diferente.Los comandos no devuelven texto,sino que devuelven un objeto(pudiendo iterar sobre sus propiedades).
Si hago un ls en PS no se me devolverá texto,sino un arreglo de objetos File

>ls | ft <- realmente me está formateando ya la salida en formato tabla

IMPORTANTE: de forma similar a Bash,puedo redireccionar la salida del comando de la izquierda a la entrada del comando de la derecha con un pipe '|'
Ejemplo: si hago un Format-List veré las propiedades del objeto listadas en cada linea:
>ls | fl

Name           :   _viminfo
Length         : 16378
CreationTime   : 28/05/2021 22:17:40
LastWriteTime  : 27/03/2022 10:51:51
LastAccessTime : 27/03/2022 10:51:51
Mode           : -a----
LinkType       :
Target         :   _viminfo

Puedo ver que las propiedades son Name, Length,CreationTime,etc...

Otro comando útil es Get-Process que me devuelve todos los procesos en ejecución.Puedo contarlos con el comando Measure:
>ls | Measure

* Por defecto Measure va a tratar de hacer la media,el máximo,mínimo,acumulado,etc(trata de obtener diferentes medidas).Dado que es un ls no tiene sentido un máximo o mínimo,asi que sólo devolverá la cuenta de archivos listados

╰─ ls | measure

Count    : 36
Average  :
Sum      :
Maximum  :
Minimum  :
Property :

NOTA: puedo ver que esta vez eligió el Format-List,dado que era sólo un objeto.Obviamente puedo formatearlo a una tabla

			COMANDOS IMPORTANTES where - sort - foreach

Si bien Measure o Get-Process no son comandos muy importantes,hay varios comandos que usaré mucho ya que son básicos.

1- Comando Where: El comando Where { condition } me permite filtrar objetos en base a una condición lógica

>ls | Where { $_.Extension -eq '.txt' } <- fijate en los espacios,en que Extension es una propiedad, en el -eq para equal y en que es un string con '.txt',pues es una Extension

NOTA: puedo usar single quotes o double quotes.

Obviamente puedo usar la clausula where sobre la salida de cualquier comando.Por ejemplo,veamos como obtener los procesos que llevan más de 5 segundos ejecutandose:
>Get-Process | where { $_.CPU -gt 5 } | select -First 1 <- fijate como puedo emular a head o tail con select -First 5 o select -Last 5.También al ser un numero no debo usar 
Obviamente puedo usar la clausula where sobre la salida de cualquier comando.Por ejemplo,veamos como obtener los procesos que llevan más de 5 segundos ejecutandose:

>Get-Process | where { $_.CPU -gt 20 } | select -First 1 <- fijate como puedo emular a head o tail con select -First 5 o select -Last 5.También al ser un numero no debo usar comillas en la condicion.

2- Comando Sort: El Comando Sort { $_.Property } me permite ordenar por una propiedad del Objeto.Por ejemplo ordenemos los procesos que llevan más de 20 segundos por su ID:
>Get-Process | where { $_.CPU -gt 20 } | Sort { $_.Id } | select -First 5

IMPORTANTE: el $_ representa el objeto actual en la iteracción.La primera vez $_ será el File(o Proceso) numero 1,despues $_ será el segundo,etc.Es la iteracción actual.
El punto(.) por otro lado indica a Powershell que quiero acceder a una propiedad del objeto

-3 Comando ForEach: el comando ForEach { action to do } es más complicado de entender ya que se usa de dos maneras diferentes.HACE UNA SOLA COSA,PERO SE USA PARA DOS.
UNA: ForEach iterará por cada objeto que le pase y ejecutará el código de su interior(es como un map o el forEach de Javascript).Esta es la forma más simple de uso.Por ejemplo:
>ls | ForEach { echo 'I found something' } <- simplemente iterará

IMPORTANTE: ForEach retornará también Objects,pudiendo encadenarlos.Aqui es donde entra la segunda forma en la que es usado ForEach.
DOS: puedo usar ForEach para filtrar Objetos bajando hasta las propiedades.Por ejemplo,ya sabemos que Measure va a fallar sobre un File,pues no es un conjunto de numeros.Puedo entrar hasta la propiedad Size de cada File para poder hacer la media correctamente:
ls | ForEach { $_.Name } <- fijate que filtra por el Name

IMPORTANTE: Measure por defecto sólo va a obtener el sumatorio.Para que realice un máximo,mínimo,media,etc debo pasarle su flag(Measure -Average en este caso):

╰─ ls | foreach { $_.Length } | measure -Average


Count    : 36
Average  : 1394,80555555556
Sum      :
Maximum  :
Minimum  :
Property :

Ejercicio: obtener todos los procesos con Id mayor a 4000 y traer la media del CPU time:
>Get-Process | where { $_.Id -gt 4000 } | foreach { $_.CPU } | Measure -Average -Sum 

Puedo observar que where y foreach tal como comenta el autor son comandos fundamentales.
En el siguiente video veré la sintaxis,como descubrir los comandos,las flags,...

			VIDEO 02 GOING FURTHER WITH POWERSHELL

Dado que escribir comandlets como Set-Location es muy largo es por esto que existen aliases.Por ejemplo where era realmente un alias para Where-Object 
Fijate que en powershell puedo posarme en Files,en cualquier Objecto,no solo en directorios(pues no lo consigo).
IMPORTANTE: en Windows existe el concepto de Drives o Discos,siempre seguirán la sintaxis <name>: por ejemplo C: o D: o Root: Obviamente en Linux cambia y solo existe root(/).

Para ver los discos tengo el comando Get-PSDrive.Veré que el registro es un Drive,por ejemplo.

NOTA: un Commandlet es un Object también.En PS casi todo comando está construido con la estructura Verb-Noun.Asi pues cada comando es un objeto con las propiedades Name(Verb+Noun),Verb,Noun,Parameters
Un parámetro en esencia es una forma de darle más detalles a un comando.Por ejemplo,el comando Subscribe-Channel no vale de nada sin un parámetro, pues obviamente necesito un canal al que suscribirme.
Los parámetros pueden ser obligatorios o requeridos

IMPORTANTE: siempre que un comandlet requiera argumentos y no se los pase en el comando inicial me los pedirá por consola

NOTA: puedo ver la ayuda de cualquier comando y ver si los argumentos son obligatorios o opcionales.Obligatorios van entre <> y opcionales entre []. Por ejemplo:
Get-Service [[-Name] <string[]>]  [<CommonParameters>]
* Puedo ver que todos son opcionales,

También es importante entender que muchos comandos tienen variaciones,asi,puedo buscar fácilmente por archivos de una extensión determinada con 
>ls *.txt
O también
>ls | where { $_.Extension -eq ".txt"}
Obviamente la primera forma es más útil.Recuerda que si uso -Like se me permite usar las wildcards * para usar regexp.

TEORIA: POWERSHELL corre sobre el CLR(Core Language Runtime).Este Core es responsable incluso de dejar que PS se ejecute,ya que provee el 'JIT compiler'.También provee un Garbage Collector,entre otras cosas más.Sea como sea es importante entender que Powershell depende del CLR.
Si bien el CLR permite realizar esto contra el hardware,para poder usarlo se necesita .NET,el cual está sobre el CLR(pero muy integrado con él).Recordando el ls anterior,que devuelve Files,estos Objetos File están echos en DotNet

También están las Libraries,básicamente permiten añadir sus propios Objects,extendiendo funcionalidad(cada archivo dll es una libreria).Por ejemplo tengo a .net dll.
Se puede añadir cualquier libreria a casi cualquier cosa en informática

			VIDEO 03 VARIABLES + NOTEPROPERTIES + CSV FILES

Una variable en su forma más simple es un lugar en la memoria donde puedo almacenar objetos.Cada variable tendrá un nombre único que la identifique.Siguiendo los ejemplos anteriores puedo almacenar los procesos con un uso de CPU mayor al 20% en una variable:
* Despues mediremos la media y filtraremos por alguna condición.También los ordenaremos.Es por esto que almacenar la primera operación en una variable es una buena idea.

>$expensiveProcesses = Get-Process | where {$_.CPU -gt 20}

TIP: es más eficiente almacenar el Get-Process | {} inicial en una variable que recalcularlo en cada instrucción por la consola.Asi que el uso de variables es una buena idea en varios sentidos

Para almacenar la data en una variable simplemente la asigno a $<varName>.Para leerla usaré la misma sintaxis:
>$expensiveProcesses	<- esto llamará al otro comando,imprimiendolo
>$expensiveProcesses | foreach { $_.CPU } | Measure -Average <- fijate como el foreach está actuando de filter,de echo no funcionaría el Measure sin él.

TIP: fijate que puedo acceder con $person.Name a un objeto que tuviera la propiedad Name(recuerda que serán mayúsculas en C#).

			COMANDO IMPORT-CSV

Este comando Import-Csv toma toda la información de un archivo CSV y la transforma en Objetos(en una tabla de registros donde cada registro es un Object).
TIP: PS también carga XML y JSON
>$students = Import-Csv -Path 'students.csv

NOTA FUNDAMENTAL: un CSV no sabe distinguir entre texto y numeros(no sucede lo mismo con xml o json)(yo creo que en realidad entrega todo como Strings y hay que convertir a int) 	
>$t="123"
>$t + 1 <- me dará el string 1231
>[int]$t +1 <- me dará 124

Con todo esto en mente hay que parsear las columnas Maths y Age:
>$students | foreach { $_.Maths = [int]$_.Maths} 
>$students | foreach { $_.Age = [int]$_.Age} 
Y ya podria sabar la media correctamente:
>$students | foreach { $_.Maths } | Measure -Average -Maximum -Minimum -Sum

			PROPERTIES - NoteProperty

Las properties no son lo único que puedo encontrar en un Object en PS.Hay más cosas,aunque normalmente no son importantes.
Otras,como ScriptProperty,que permite ejecutar un pequeño script al acceder a la property si puede ser importante.
Sabiendo esto,también debo saber que cualquier property está o existe físicamente en DotNet(es decir,que su código ya existia antes de arrancar la Powershell).
Es decir,que no puedo hacer que un File no tenga la propiedad Size o Extension,ya que ese código no es de mi acceso.No puedo remover ni,obviamente,añadir.

IMPORTANTE: sin embargo,si que hay una cosa especial que puedo hacer,y es añadir una NoteProperty a cualquier Object,en cualquier momento, mientras esté corriendo Powershell.

De echo,todas las properties que resultaron de leer el csv con Import-Csv son NoteProperties,ya que no existen en .NET,sólo existen para esa ejecución de la terminal.

Con todo esto en mente,podemos crear otra nueva columna/NoteProperty que sea la resultante de sumar las columnas English y Maths,para despues EXPORTAR ESE CSV, con el comando Export-Csv.Genial

		AÑADIENDO PROPIEDADES A OBJETOS - Add-Member

Primero guardamos un File,que será nuestro csv:
>$file = ls | where { $_.Name -Like "*.csv" }
Añadamos una Columna/NoteProperty "Importance".Para ello voy a usar el comando Add-Member.La sintaxis es Add-Member -InputObject <ObjectName> -MemberType <Type> -Name <Name> -Value <Value>

>Add-Member -InputObject $file -MemberType NoteProperty -Name 'Importance'
*Desafortunadamente tengo que pedir explicitamente esta propiedad:
>$file | ft -Property Name,Lenghth,Importance

╰─ $file | ft -Property Name,Length,Importance

Name         Length Importance
----         ------ ----------
students.csv   2323          0

Obviamente ahora ya puedo cambiarla:
>$file.Importance = 5

>$students | foreach { Add-Member -InputObject $_ -MemberType NoteProperty -Name 'Sum' -Value ($_.Maths + $_.English) } <- ojo con los parentesis,asinto

Ya puedo guardarlo a un .csv:
>$students | Export-Csv 'WithNoteProperty.csv' <- Perfecto

IMPORTANTE: el comando anterior es demasiado largo,no sería mejor que hubiera una forma de reducirlo?.La verdad es que la hay,usando alias.Lo veré en breve.


			VIDEO 04 TYPES + METHODS + CASTING

Tal como ya hemos mencionado el comando para añadir la nueva columna es demasiado largo.¿Como podría acortarlo?.

Uno: Hay un alias para ForEach,es el simbolo del porcentaje:
$students | % { $_.English = [int]$_.English } <- esto resume un poco,si

Dos: No necesito usar -InputObject ,puedo pipear el objeto al comando:
$students | % { $_ | Add-Member

Tres: Dado que siempre que se usa Add-Member,o al menos el 95% de las veces, es para añadir una NoteProperty hay un atajo que creo el equipo de Powershell:
$students | % { $_ | Add-Member -NotePropertyMembers @{Sum=($_.Maths + $_.English)}  }
* puedo traducirlo por añado una NoteProperty que será la resultante de sumar esa operación(y el nombre??) 
TIP: veré más sobre como usar @{} más adelante

				   TYPES FOR OBJECTS

IMPORTANTE:como ya he podido apreciar los Objects son la parte central de Powershell.En Powershell todo Object tiene un Type atado a él.Cada Type describe los miembros que un objeto tendrá.(Estos tipos vienen de .NET).
Por ejemplo,cuando haga un Get-Process recibiré un arreglo de objetos Process.Obviamente,es como una clase,cada instancia tendrá las mismas propiedades/miembros.
NOTA: en Powershell para referirme a un Type tengo que usar square brackets y el type dentro:
[string]
[int]
Fijate que son los primitivos de C#.

TIP: puedo obtener información sobre un type con [type]
>[bool]

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Boolean                                  System.ValueType

			CASTING DE TYPES

Ya he visto antes como castear a otro tipo.Para hacerlo simplemente paso el [type] antes:
$s = "123" <- es un string
[int]$s <- ahora será el number 123
TIP: el casting convierte un tipo de objeto a otro.
Obviamente,no puedo castear todo,no podría castear un Number a File,pues no tiene sentido

				PROPERTIES IN-DEPTH

Toda Property tiene un Name + un Type,por ejemplo la Property Extension de un File es de tipo String.O la property Name de ese Objeto File también será un String.
Este tipo de Properties no puedo cambiarlas el Type,a diferencia de las NoteProperties,que si puedo darlas el Type que necesite.

			METHODS IN POWERSHELL

Realmente está bastante claro ya que los Objects en PS tendrán properties no customizables y otras que puedo crear.Pero también puedo ejecutar acciones contra los objetos,puedo darles comportamiento.Para ello usaré los methods.
Un method es un bloque de código que puede ejecutar cierta acción al llamarse(start a process,delete a file,..
Hay que tener en cuenta que diferentes tipos de Object tendrán diferentes tipos de métodos disponibles.
TIP:cada mismo tipo de objeto compartirá los mismos métodos(cada File puede hacer lo mismo,cada Process lo mismo,...
Obviamente un método puede tomar argumentos,de echo es bastante normal.

NOTA: Powershell tratará de hacer coincidir los types de los argumentos.A esto se le llama autocasting.Por ejemplo puedo pasarle un File aunque espere un string[]:
>Import-Csv -Path $file <- tratará de pasar el File a String
Powershell es bastante potente a la hora de hacer autocasting,claro que obviamente tiene sus límites

IMPORTANTE: los métodos también devolverán Objects.Sin embargo,no todo método devuelve algo,pero en caso de hacerlo devolverá un Object.Bien.Es hora de ver como se llaman en PS

			CALLING METHODS IN POWERSHELL

Puedo empezar con el método GetType.Todo Objeto en PS tiene acceso a este método,el cual,obviamente nos dice el tipo o clase del Objecto:

╰─ $s="string"

╭─ ♥ 09:33 |          PowerShellSeries
╰─ [string]
IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                                   System.Object

╰─ $s.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                                   System.Object

Puedo ver que tanto llamar a [string] como a "hola".GetType()  me devuelve el mismo Objct.

TIP: para saber el nombre programático de un File lo tengo en la property Name:
╰─ $file.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     FileInfo                                 System.IO.FileSystemInfo

Asi pues,un File es de tipo FileInfo.

Puedo ejecutar un método por cada iteración,por ejemplo.
>Get-Process | % { $_.GetType() } 

TIP: realmente GetType puede arrojar mucha más información,pero tengo que imprimirla en formato lista y no tabla para ver la que estaba oculta:
> "hola".GetType() | fl

BaseType                   : System.Object
UnderlyingSystemType       : System.String
FullName                   : System.String
AssemblyQualifiedName      : System.String, mscorlib, Version=4.0.0.0, Culture=neutral,
PublicKeyToken=b77a5c561934e089
Namespace                  : System
GUID                       : 296afbff-1b0b-3ff5-9d6c-4e7e599f8b57
IsEnum                     : False

Puedo ver que son muchas y realmente complejas,no son necesarias de momento.

				CHAINING METHODS

También puedo encadenar métodos,por ejemplo GetProperties() me devuelve las propiedades de un Type y getType me devuelve un Type,luego:
╰─ "hola".GetType().GetProperties() | ft

MemberType Name   DeclaringType ReflectedType MetadataToken Module                       PropertyType Attributes CanRead CanWrite
---------- ----   ------------- ------------- ------------- ------                       ------------ ---------- ------- --------
Property Length System.String System.String     385876102 CommonLanguageRuntimeLibrary System.Int32       None    True    False
Property Chars  System.String System.String     385876101 CommonLanguageRuntimeLibrary System.Char        None    True    False


Puedo ver que Length es un Int32 y Chars es un Char

			COMMANDS VS METHODS

Por último debo comprender la diferencia entre comandos y métodos.Por ejemplo,para borrar un objeto puedo usar el comando Remove-Item o el método .Delete():
$obj | Remove-Item <- puedo borrar algo usando el comando ó
$obj.Delete() <- también puedo borrarlo usando el método

TIP: puedo cambiar los permisos a un archivo con takeown( /a /r /f) + ruta.Ejemplo:
>takeown /a /r /f C:Documents <- /a es para que los coga el administrador,pero puedo omitirlo y tomará control el user actual.
Este comando requiere de una consola elevada en permisos.

NOTA: el consejo es que use el comandlet siempre que exista y cuando no exista ya use métodos.Es decir,que los métodos son para cosas más complejas,seguramente tenga que definirlos y desarrollarlos primero.

		EPISODE 5 METHODS WITH PARAMETERS- OVERLOAD OF METHODS

Este video es la parte dos del anterior.Nos acercamos también a una GUI que haremos con botones y todo en PS.
Types: recuerda que cada Object tiene un Type(Class),por ejemplo puede ser de Type Process o File.Según el tipo,tendrá ciertas Properties y Methods disponibles,y puedo agregar NoteProperties también durante la session.

TIP: puedo usar el método GetType en cualquier objeto,es un método sobre el que toda instancia tiene visión:
"hola".GetType() <- fijate que me devolverá el Type el método

IMPORTANTE: y de igual manera que puedo ver las properties de un Type con Type.GetProperties() también puedo ver los métodos con Type.GetMethods()

			PARAMETERS IN METHODS

Si intento mover un file(un Object) con Object.MoveTo() sin usar argumentos veré el siguiente error:

╰─ $file.MoveTo()
No se encuentra ninguna sobrecarga para "MoveTo" y el número de argumentos "0".
En línea: 1 Carácter: 1
+ $file.MoveTo()

NOTA:el argumento además es de tipo string,no sólo tendré que cumplir con el número de argumentos del método,sino con sus tipos.

Lo mismo ocurrirá con String.Replace(a,b).Necesitará dos argumentos o no funcionará:
╰─ "a,b".Replace(',','-');

			FORMAL DESCRIPTIONS OF METHODS

Bien,debe haber una forma de consultar cada método,con sus sobrecargas,número de argumentos,orden de los mismos,..,no?
void Close()
bool WaitForExit(int miliseconds)
void M(string a,int b)
TIP: puedo ver que esto es C#.PowerShell va a seguir su sintaxis.Dado que C# está escrito sobre .NET y PowerShell también,se compartirá el lenguaje.Bien.

string A { get; } <- getter,puedo leer la info(con un setter la cambiaré)

			VIEWING MEMBERS

Con el método Get-Member puedo listar todos los Members de un Object(tanto las Properties como los Métodos).Es un método fantástico para ver todo lo que tiene un Objeto:
>Get-Process | Get-Member


   TypeName: System.Diagnostics.Process

   Name                       MemberType     Definition
   ----                       ----------     ----------
   Handles                    AliasProperty  Handles = Handlecount
   Name                       AliasProperty  Name = ProcessName
   NPM                        AliasProperty  NPM = NonpagedSystemMemorySize64
   PM                         AliasProperty  PM = PagedMemorySize64
   SI                         AliasProperty  SI = SessionId
   VM                         AliasProperty  VM = VirtualMemorySize64
   WS                         AliasProperty  WS = WorkingSet64
   Disposed                   Event          System.EventHandler Disposed(System.Object, Sy...
   ErrorDataReceived          Event          System.Diagnostics.DataReceivedEventHandler Er...
   Exited                     Event          System.EventHandler Exited(System.Object, Syst...
   OutputDataReceived         Event          System.Diagnostics.DataReceivedEventHandler Ou...
   BeginErrorReadLine         Method         void BeginErrorReadLine()
   BeginOutputReadLine        Method         void BeginOutputReadLine()
   CancelErrorRead            Method         void CancelErrorRead()
   CancelOutputRead           Method         void CancelOutputRead()
   Close                      Method         void Close()
   CloseMainWindow            Method         bool CloseMainWindow()

Puedo ver en la Propiedad MemberType el tipo de cada Member,si es un Method o AliasProperty o Property,Event,etc...
IMPORTANTE: en algunas Properties veré tanto si sólo las puedo leer como si las puedo modificar:
MaxWorkingSet              Property       System.IntPtr MaxWorkingSet {get;set;}
MinWorkingSet              Property       System.IntPtr MinWorkingSet {get;set;}
Modules                    Property       System.Diagnostics.ProcessModuleCollection Mod...
NonpagedSystemMemorySize   Property       int NonpagedSystemMemorySize {get;}
NonpagedSystemMemorySize64 Property       long NonpagedSystemMemorySize64 {get;}

Las que tenga acceso al getter y setter veré {get;set;}.Perfecto.

				SOBRECARGA DE MÉTODOS

Bien,si me fijo en este método,veré que tiene varias formas posibles de llamarlo:
WaitForExit                Method         bool WaitForExit(int milliseconds), void WaitForExit()
WaitForInputIdle           Method         bool WaitForInputIdle(int milliseconds), bool WaitForInputIdle()
A esto se le llama sobrecarga de métodos.Realmente son varios métodos,todos con el mismo nombre,y según el número y orden se llamará a uno u otro.

TIP: si llamo aun método por referencia PS me dirá su sobrecarga:
╰─ "a".Replace

OverloadDefinitions
-------------------
string Replace(char oldChar, char newChar)
string Replace(string oldValue, string newValue)

Esto es genial,ya que antes de llamarlo puedo consultar rápidamente su sobrecarga.
TIP: recuerda que where es como find,devolverá las iteracciones que se resuelvan a true.

		EXPERIMENTING WITH TYPES

Ya sé que ls me muestra todos los files y directories,pero si quisiera puedo listar sólo los directorios:
>ls -Directory
Bien,obviamentes esto es lo que haré cuando quiera ver sólo los directorios,usar la flag,pero que tal si lo hacemos filtrando los Types,ya que estamos viendo Types?:

╰─ ls | % { $_.GetType() }

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     DirectoryInfo                            System.IO.FileSystemInfo
True     True     FileInfo                                 System.IO.FileSystemInfo
True     True     FileInfo                                 System.IO.FileSystemInfo
True     True     FileInfo                                 System.IO.FileSystemInfo
True     True     FileInfo                                 System.IO.FileSystemInfo

Con esto en mente podría listar los directorios asi:
╰─ ls | ? { $_.GetType().Name -eq "DirectoryInfo" }

			VIDEO 06 PRIMITIVES - IMPORTANT TYPES + NEW KEYWORD	

Algunos objetos son tan fundamentales,como los numeros o boleanos,que no pueden ser descompuestos en propiedades más pequeñas	
NOTA: los primitivos son tipos especiales de objetos,hay muy pocos,y son tan básicos que no pueden ser descompuestos en tipos más pequeños.	
TIP: los primitivos son creados en el CLR.Todo el sistema de objetos y de métodos viene de alli,del CLR.

Los primitivos más comunes son :

byte (Byte)        sbyte(Sbyte)   
short (Int16)      ushort(UInt16)
int (Int32)        uint(UInt32)
long (Int64)       ulong(UInt64)
float(Single)     <- 32bits ú 4bytes
double(Double)    <- 64bits ú 8bytes
decimal(Decimal)  <- 128bits <- realmente no es un primitivo

string  <- realmente es un array de char
char
array

* Fijate que short son 16bits,o sea 2 bytes,obviamente byte es un byte u 8 bits y el int son 32bits u 4 bytes.El long gastará 8 bytes en memoria(o 64bits).Todos tienen su version unsigned.Además,casi siempre trabajaré con int o long

En cuanto a operaciones puedo ejecutar las ya conocidas en PowerShell.Incluso puedo usar el shortcut <operation>=.Es decir:
$num = 3;
$num += 2 <- igual que $num = $num + 2;

TIP: hay una propiedad isPrimitive de tipo bolean que puede decirme si el tipo es primitivo:
╰─ [bool].IsPrimitive
True

╰─ [int].IsPrimitive
True

╰─ [string].IsPrimitive
False

╰─ [char].IsPrimitive
True

Puedo ver que int o char son primitivos y string no.Sin embargo tecnicamente para muchos lo es y además es tratado de forma muy especial por la CLR de DotNet.

NOTA:puedo usar comillas simples o dobles sobre un string,sin embargo no son lo mismo en la PowerShell.
SINGLE QUOTES
Cuando use single quotes todo lo que escriba dentro de ellas será tratado como un literal,como lo que es o pone:
╰─ 'hello $name'
hello $name
Si quisiera escapar una comilla doble tengo que usar otra,y no el caracter de escape:
╰─ 'hello ''$name'
hello '$name
DOUBLE QUOTES
Son casi lo mismo,con la excepción de que pueden interpretar una variable:
╰─ "El num es $num"
El num es 3
Es como se hace la interpolación de variables,de echo puedo meter lógica alli:
╰─ "Y ahora el num es $($num+2)"
Y ahora el num es 5
Logicamente,puedo concatenar strings con el operador +:

╰─ $str="el num es"
╰─ $str +  ":"
el num es:

NOTA: un array es una colección de objetos(de strings,o numeros,etc).Un string tecnicamente es un string de chars,aunque es tan común que se ha abreviado su construcción a unas simples comillas.Sin embargo sigue siendo un array por detrás.

Además,ya hemos estado trabajando con arrays.Un ls tecnicamente me devuelve un array de Files y Directories y Get-Process me devolvió un array de Process.

			OTHER IMPORTANT TYPES

Sin embargo,sólo con los tipos primitivos no llegaría lejos.Otros tipos como Date o DateTime,File,Directory son casi tan importantes como los primitivos.
Puedo incluso crear objetos con ellos,por ejemplo una instancia de StringBuilder:

╰─ $sb = [System.Text.StringBuilder]::new()

╰─ $sb.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     StringBuilder                            System.Object

Fijate en el uso de ::new().Algunos constructores pedirán parámetros,como el de la clase DateTime:
╰─ [DateTime]::new()
No se encuentra ninguna sobrecarga para "new" y el número de argumentos "0".
En línea: 1 Carácter: 1
+ [DateTime]::new()
* puedo ver la sobrecarga de métodos con [Type]::method <- sin llamarlo
╰─ [DateTime]::new

OverloadDefinitions
-------------------
datetime new(long ticks)
datetime new(long ticks, System.DateTimeKind kind)
datetime new(int year, int month, int day)

Ahora si,sabiendo los argumentos puedo crear mi objeto
╰─ [DateTime]::new(1988,5,26)

jueves, 26 de mayo de 1988 0:00:00

Claro que es un poco engorroso crear objetos asi,es por ello que existe el comando New-Object <Class>.

			CREATING AND USING ARRAYS

Bien,pero,¿como creo un array en PS?.Fácil,para ello debo usar la sintaxis @() con los elementos separados por comas:
@('Alex','Mike','John') <- Powershell creará un array
Cada elemento del array será un Item o Element accesable por su indice:
╰─ $arr[0]
John

Puedo ver que el tipo del arreglo es Object[]
╰─ $arr.GetType().Name
Object[]

Ahora ya puedo empezar a hacer cosas tan fancy como estas:
$arr | % { "Name: $_" }
Name: John
Name: Mike
Name: August

Puedo ver que,obviamente,muchos comandos me devuelven arreglos:
╰─ (Get-Process).GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Object[]                                 System.Array

Fijate en la sintaxis (comand).GetType() en vez de comand.GetType.Esta sintaxis hace tratar toda la salida del Get-Process como una única cosa,en vez de ejecutar GetType por cada linea.
Sabiendo esto también puedo acceder al indice 0 de toda la salida:
(Get-Process)[0] <- esto me dará el primer proceso

Puedo ver también de esta forma el nº de procesos corriendo:
(Get-Process).Length
180 <- realmente son demasiados para tener solo la Powershell corriendo,no?

TIP:ya hemos recalcado que un string es un arreglo de char,no?Comprobemoslo:

╰─ $str = 'abc';

╰─ $str[1]
b <- esto confirma que es un arreglo de chars.
Fijate que es bastante sencillo todo en Powershell.

		VIDEO 07 SCRIPTING IN FILES + HASHTABLES + STATIC

Un script no es más que un File con código de Powershell en él.Esto hará que sea ejecutable y pueda correr/ejecutar el script del archivo.
Cuando lo haga ejecutará secuencialmente todas las lineas del archivo,de arriba a abajo.

NOTA: para crear un script en PS tiene que ser un file con extensión .ps1.
Puedo crear el file con echo "" > file.js o con type nul > file.ps1.Investigar más sobre esto.
TIP: y para ejecutarlo simplemente uso ./script.ps1.Puede que tenga deshabilitado la ejecución de scripts en el sistema(restricted).
IMOPORTANTE: Powershell siempre vendrá con la ejecución de scripts deshabilitada por defecto para evitar que un usuario inexperto tenga problemas
Fijate que puedo ponerla en undefined,allSigned,remoteSigned o unrestricted.Parece que remoteSigned me permite ejecutar cualquier script de mi máquina y los de afuera tengo que desbloquearlos primero,lo cual la hace mejor opción que unrestricted.

Bien,hagamos un pequeño script que sume dos enteros que introducirá el usuario.

Write-Output 'Please enter the first number:';
$first = [int](Read-Host); # fijate como necesita parentesis
# $first.GetType();

Write-Output 'Please enter the second number:';
$second = Read-Host;
# $second.GetType();

$total = $first + [int]$second; # obviamente puedo parsear despues

Write-Output "The sum of $first and $second is $total." #recuerda que los double quotes interpretan las variables

		STATIC MEMBERS

Empecemos con esto [type]::thing .Bien,todo Object en PowerShell tiene Members,y recuerda que tendrá diferentes basandose en su Type.
Es decir un Objeto File tendrá el Member Name,por ejemplo,pero lo que guarde este Member o propiedad será diferente para cada File(propiedad no estática).
Y lo mismo para los Methods, si llamo a Delete sobre un File borrará ese File.

Sin embargo existe algo llamado Static Members, y a diferencia de los Non-Static Members o Methods,estos Static Members compartirán su valor entre todos los Objects de ese Type.No existen en el Objeto de forma individual,sino en el Type(o clase).
Ya lo vi con DateTime::new , pertenece a la clase y sólo hay uno,aunque en este caso estamos hablando de un Method,pero es lo mismo para una propiedad.

IMOPORTANTE: la forma de acceder a un miembro estático es con [type]::Member.
Puedo ver todos los Members estáticos de un type usando el método Get-Member sobre un [type] y la flag -Static para que no saque todos:

╰─ [datetime] | Get-Member -Static

   TypeName: System.DateTime

Name            MemberType Definition
----            ---------- ----------
Compare         Method     static int Compare(datetime t1, datetime t2)
DaysInMonth     Method     static int DaysInMonth(int year, int month)
Equals          Method     static bool Equals(datetime t1, datetime t2), static bool Equ...
FromBinary      Method     static datetime FromBinary(long dateData)

Puedo ver el MemberType(en este caso los primeros 4 Method y una Definition con la sobrecarga,etc...
* Fijate que tendre que acceder con datetime:: a estos métodos.
* Fijate el constructor que usé como es estático: 
new             Method     datetime new(long ticks), datetime new(long ticks, System

Y leyendo esto puedo aprender como mostrar la date time actual(y como solo es un getter)
Now             Property   datetime Now {get;}

NOTA: hay incluso Types o Clases que sólo tienen Members Statics,como [Environment]:

			HASH TABLES

Bien, una vez visto como acceder y tener un listado de Members estáticos, nos falta ver qué es esto @{}. En el episodio anterior ví que con @(val1,val2,val3) creo un array,pero que hace con llaves?
TIP: la razón por la que la sintaxis es muy similar es que ambos crean Colecciones(de echo heredan de ICollection).
Bien,@{} lo que hace es crear una hast table,donde se guardarán pares de clave-valor y serán accesados por la key.Es decir,que es el tipico Map u Object Literal.

  HASH-TABLE
     Key    Value
   'Alex'   200
   'Mike'   24
   'Tom'    45

Eso es una hash-table.Fijate que es igual que un array,pero me permite elegir a mi la key:

  ARRAY
   Key    Value
   0      200
   1      24
   2      45

Bien,la forma de crear un Map es con @{ key = value; key = value; } separandolos con punto y coma:
@{ First = 4; Second = 4 }
Para acceder habrá que hacerlo con propiedades computadas.Ojo,que serán String:
$ht['First'] ó $ht['Mike']

Ejemplo:
$ht = @{ Alex = 200; Tom = 50 }

╰─ $ht['Alex']
200

IMPORTANTE: para añadir una nueva key con su value a una hash table sabiendo lo que sé lo mejor es ver la documentación:

─ $ht | Get-Member


   TypeName: System.Collections.Hashtable

Name              MemberType            Definition
----              ----------            ----------
Add               Method                void Add(System.Object key, System.Object value)...
Clear             Method                void Clear(), void IDictionary.Clear()
Clone             Method                System.Object Clone(), System.Object ICloneable....
Contains          Method                bool Contains(System.Object key), bool IDictiona...
ContainsKey       Method                bool ContainsKey(System.Object key)
ContainsValue     Method                bool ContainsValue(System.Object value)
CopyTo            Method                void CopyTo(array array, int arrayIndex), void I...
Equals            Method                bool Equals(System.Object obj)
GetEnumerator     Method                System.Collections.IDictionaryEnumerator GetEnum...
GetHashCode       Method                int GetHashCode()
GetObjectData     Method                void GetObjectData(System.Runtime.Serialization....
GetType           Method                type GetType()
OnDeserialization Method                void OnDeserialization(System.Object sender), vo...
Remove            Method                void Remove(System.Object key), void IDictionary...
ToString          Method                string ToString()

Puedo ver que puedo añadir con Add(key,value) o borrar con Remove(key) y obviamente operar de la forma que considere oportuno
$ht.Add('Pepe',40); <- parece que la key debe ser un String también.

IMPORTANTE: una hash table no es reconocida como una colección iterable.Ejecutar un for-each o Measure dará error o extraños resultados.
Para evitar esto debo convertirla a un iterable con GetEnumerator().Nada más:

╰─ $ht | % { $_.Name }
  <- no sale nada,pues no consigue iterar sobre el Map
╰─ $ht.GetEnumerator() | % { $_.Name }
Julen
Alex
Tom

Lo mismo para obtener la length:
╰─ $ht.GetEnumerator() | Measure

Count    : 3

NOTA: puedo castear una Hash Table a Object asi:
$obj = [PSCustomObject]$ht

El Map pasará a ser un Object con las Propiedades Julen,Alex y Tom.No confundas un	Literal Object con un Map

			MULTI-LINE STATEMENTS

¿Que pasa si quiero ejecutar múltiples lineas en un script?Para ello puedo separar las instruccions por punto y coma y saltar de linea,aunque PowerShell ya va a interpretar cada linea como una instruccion,igual que Python:

@(1,2,3) | ForEach-Object {
    Write-Output "Hello!"
    Write-Output "World!"
}

Obviamente podia usar una linea: @(1,2,3) | % { echo "Hello"; echo "World"; }

NOTA: Incluso puedo crear el arreglo en multiples líneas:
@(
  1
  2
  3
) <- e incluso no necesito el separador si lo hago asi.Puedo ver que coge prácticas de muchos sitios,se ve que que es más nuevo que Bash.
IMPORTANTE: esto no solo funciona en un file .ps1, también en la terminal,simplemente tengo que dar un intro.

			SECOND SCRIPT

Este script va a ser más interesante.Va a listar el LineCount de los todos files en la posición actual,diciendome el nº de lineas de cada archivo

$files = ls;
$files | % { $_ | Add-Member -NotePropertyMembers @ { LineCount = 0 } }
$files | ft -Property @('Name','LineCount')

Fijate que ft -Property lleva un array de strings con las props a mostrar ya que por defecto están ocultas las Customproperties

Por último,nos queda averigüar el número de lineas.Get-Content(file) justo nos devuelve el contenido de un file en un array de lineas.Con saber su length bastará:
$noOfFiles = (Get-Content $_).Length:

$files = Get-ChildItem;

$files | ForEach-Object { 
  $noOfLines = (Get-Content $_).Length
  $_ | Add-Member -NotePropertyMembers @{ LineCount = $noOfLines }  
};

$files | Format-Table -Property @('Name','LineCount');

Genial.Todo más claro que el caldo de un asilo.

			VIDEO 08 IF OPERATORS - TAKING SCRIPTING FURTHER

Un operador es una herramienta del lenguaje que me permite realizar operaciones especificas de algun tipo sobre algunos lenguajes.Por ejemplo, el operador -eq compara dos objetos.Otro operador que he usado mucho es el de casting [type]$a.Y otro que he usado mucho es el operador punto(.) que me permite acceder a las propiedades.Otro más es el ::, que me permite acceder a miembros estáticos.

COMPARISON OPERATORS: como operadores de comparación tengo gt,ge,eq,ceq,like,match,lt,le,etc...Siempre arrojarán un resultado boleano tras realizar la comparación.

NOTA: -eq no es case sensitive:
"a" -eq "A"
True
Para que esto dé true tengo que usar el operador "-ceq",el cual aún no había visto:
"a" -ceq "A"
False

También tengo -gt -ge -lt o -le como comparadores.Aparte tengo otros donde usar wildcards como -like(wildcars de PS: * zero o más characters; :
"ana" -like "*na"
True

TIP: también tengo -notlike , -match y -notmatch

BOOLEANS OPERATORS: el operador ! invierte el resultado de un boleano:
!$true
False
Los operadores -and y -or deben cumplir ambas o una de las dos para que se cumpla a true.Recuerda que como en cualquier lenguaje los operadores siguen un orden de importancia(precedencia de operadores), siempre que tenga dudas lo mejor es usar parentesis:
($_.CPU -gt 10) -and ($_.Name -like 'ab*'); <- si no tengo claro si irá el like o el gt o el and antes siempre puedo usar paréntesis.

TIP: la mayoria de los operadores se van a comportar diferente si se les pasa una colección,tratarán de iterarla:
@('ab','bb','abc') -like '*a*'
ab
abc

IF STATEMENTS: para crear una sentencia if usaré la sintaxis if(condition){ logic}Nada nuevo,es C#
Write-Output "Do you like ABMedia? (y/n)"
$answer = Read-Host -Prompt "options are y or n"

if ($answer -ceq "y" -or $answer -ceq "yes") {
  Write-Output "You said yes.  Great!"
}
elseif($answer -ceq "n" -or $answer -ceq "no") {
  Write-Output "You said no.  That's too bad."
}
Y otro con elseif + exit(fijate que era necesario)

$percentage = [int](Read-Host -Prompt "Enter your percentage: ")

if($percentage -lt 0 -or $percentage -gt 100)
{
    Write-Output "Invalid percentage"
    exit
}  

if($percentage -ge 90){
    Write-Host "You got A+"
}
elseif($percentage -ge 80){
    Write-Host "You got A"
}
elseif($percentage -ge 70){
    Write-Host "You got B+"
}
elseif($percentage -ge 60){
    Write-Host "You got B"
}
else ....
En el siguiente video veré como debuggear código en la PS.

			VIDEO 09 DEBUGGING + SELECT + LOOPING

			

