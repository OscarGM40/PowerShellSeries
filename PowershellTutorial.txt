			 POWERSHELL TUTORIAL SERIES

Playlist: https://www.youtube.com/watch?v=hXwVm3vC-10&list=PLAVSKeDM4AqN8zINh1niRxoZKqpd9FgtE&ab_channel=ABMedia

Powershell es extremadamente útil y poderosa.Está construida sobre .NET(C# también está built in top of .NET).
El autor recomienda bajarse la última versión desde el repo de GitHub(la 6) y no usar la 5 que es la que viene instalada por defecto.
Para ver la version tipear:
$PSVersionTable <- puedo ver que tengo la 5

El principal concepto a tener en cuenta es lo que devuelve PS.En otras lineas de commando como bash,cada comando devuelve una única cosa,texto.
Si hago un ls devolverá texto,esto es muy simple y útil,pero extremadamente limitante.

Powershell toma una aproximación diferente.Los comandos no devuelven texto,sino que devuelven un objeto(pudiendo iterar sobre sus propiedades).
Si hago un ls en PS no se me devolverá texto,sino un arreglo de objetos File

>ls | ft <- realmente me está formateando ya la salida en formato tabla

IMPORTANTE: de forma similar a Bash,puedo redireccionar la salida del comando de la izquierda a la entrada del comando de la derecha con un pipe '|'
Ejemplo: si hago un Format-List veré las propiedades del objeto listadas en cada linea:
>ls | fl

Name           :   _viminfo
Length         : 16378
CreationTime   : 28/05/2021 22:17:40
LastWriteTime  : 27/03/2022 10:51:51
LastAccessTime : 27/03/2022 10:51:51
Mode           : -a----
LinkType       :
Target         :   _viminfo

Puedo ver que las propiedades son Name, Length,CreationTime,etc...

Otro comando útil es Get-Process que me devuelve todos los procesos en ejecución.Puedo contarlos con el comando Measure:
>ls | Measure

* Por defecto Measure va a tratar de hacer la media,el máximo,mínimo,acumulado,etc(trata de obtener diferentes medidas).Dado que es un ls no tiene sentido un máximo o mínimo,asi que sólo devolverá la cuenta de archivos listados

╰─ ls | measure

Count    : 36
Average  :
Sum      :
Maximum  :
Minimum  :
Property :

NOTA: puedo ver que esta vez eligió el Format-List,dado que era sólo un objeto.Obviamente puedo formatearlo a una tabla

			COMANDOS IMPORTANTES where - sort - foreach

Si bien Measure o Get-Process no son comandos muy importantes,hay varios comandos que usaré mucho ya que son básicos.

1- Comando Where: El comando Where { condition } me permite filtrar objetos en base a una condición lógica

>ls | Where { $_.Extension -eq '.txt' } <- fijate en los espacios,en que Extension es una propiedad, en el -eq para equal y en que es un string con '.txt',pues es una Extension

NOTA: puedo usar single quotes o double quotes.

Obviamente puedo usar la clausula where sobre la salida de cualquier comando.Por ejemplo,veamos como obtener los procesos que llevan más de 5 segundos ejecutandose:
>Get-Process | where { $_.CPU -gt 5 } | select -First 1 <- fijate como puedo emular a head o tail con select -First 5 o select -Last 5.También al ser un numero no debo usar 
Obviamente puedo usar la clausula where sobre la salida de cualquier comando.Por ejemplo,veamos como obtener los procesos que llevan más de 5 segundos ejecutandose:

>Get-Process | where { $_.CPU -gt 20 } | select -First 1 <- fijate como puedo emular a head o tail con select -First 5 o select -Last 5.También al ser un numero no debo usar comillas en la condicion.

2- Comando Sort: El Comando Sort { $_.Property } me permite ordenar por una propiedad del Objeto.Por ejemplo ordenemos los procesos que llevan más de 20 segundos por su ID:
>Get-Process | where { $_.CPU -gt 20 } | Sort { $_.Id } | select -First 5

IMPORTANTE: el $_ representa el objeto actual en la iteracción.La primera vez $_ será el File(o Proceso) numero 1,despues $_ será el segundo,etc.Es la iteracción actual.
El punto(.) por otro lado indica a Powershell que quiero acceder a una propiedad del objeto

-3 Comando ForEach: el comando ForEach { action to do } es más complicado de entender ya que se usa de dos maneras diferentes.HACE UNA SOLA COSA,PERO SE USA PARA DOS.
UNA: ForEach iterará por cada objeto que le pase y ejecutará el código de su interior(es como un map o el forEach de Javascript).Esta es la forma más simple de uso.Por ejemplo:
>ls | ForEach { echo 'I found something' } <- simplemente iterará

IMPORTANTE: ForEach retornará también Objects,pudiendo encadenarlos.Aqui es donde entra la segunda forma en la que es usado ForEach.
DOS: puedo usar ForEach para filtrar Objetos bajando hasta las propiedades.Por ejemplo,ya sabemos que Measure va a fallar sobre un File,pues no es un conjunto de numeros.Puedo entrar hasta la propiedad Size de cada File para poder hacer la media correctamente:
ls | ForEach { $_.Name } <- fijate que filtra por el Name

IMPORTANTE: Measure por defecto sólo va a obtener el sumatorio.Para que realice un máximo,mínimo,media,etc debo pasarle su flag(Measure -Average en este caso):

╰─ ls | foreach { $_.Length } | measure -Average


Count    : 36
Average  : 1394,80555555556
Sum      :
Maximum  :
Minimum  :
Property :

Ejercicio: obtener todos los procesos con Id mayor a 4000 y traer la media del CPU time:
>Get-Process | where { $_.Id -gt 4000 } | foreach { $_.CPU } | Measure -Average -Sum 

Puedo observar que where y foreach tal como comenta el autor son comandos fundamentales.
En el siguiente video veré la sintaxis,como descubrir los comandos,las flags,...

			VIDEO 02 GOING FURTHER WITH POWERSHELL

Dado que escribir comandlets como Set-Location es muy largo es por esto que existen aliases.Por ejemplo where era realmente un alias para Where-Object 
Fijate que en powershell puedo posarme en Files,en cualquier Objecto,no solo en directorios(pues no lo consigo).
IMPORTANTE: en Windows existe el concepto de Drives o Discos,siempre seguirán la sintaxis <name>: por ejemplo C: o D: o Root: Obviamente en Linux cambia y solo existe root(/).

Para ver los discos tengo el comando Get-PSDrive.Veré que el registro es un Drive,por ejemplo.

NOTA: un Commandlet es un Object también.En PS casi todo comando está construido con la estructura Verb-Noun.Asi pues cada comando es un objeto con las propiedades Name(Verb+Noun),Verb,Noun,Parameters
Un parámetro en esencia es una forma de darle más detalles a un comando.Por ejemplo,el comando Subscribe-Channel no vale de nada sin un parámetro, pues obviamente necesito un canal al que suscribirme.
Los parámetros pueden ser obligatorios o requeridos

IMPORTANTE: siempre que un comandlet requiera argumentos y no se los pase en el comando inicial me los pedirá por consola

NOTA: puedo ver la ayuda de cualquier comando y ver si los argumentos son obligatorios o opcionales.Obligatorios van entre <> y opcionales entre []. Por ejemplo:
Get-Service [[-Name] <string[]>]  [<CommonParameters>]
* Puedo ver que todos son opcionales,

También es importante entender que muchos comandos tienen variaciones,asi,puedo buscar fácilmente por archivos de una extensión determinada con 
>ls *.txt
O también
>ls | where { $_.Extension -eq ".txt"}
Obviamente la primera forma es más útil.Recuerda que si uso -Like se me permite usar las wildcards * para usar regexp.

TEORIA: POWERSHELL corre sobre el CLR(Core Language Runtime).Este Core es responsable incluso de dejar que PS se ejecute,ya que provee el 'JIT compiler'.También provee un Garbage Collector,entre otras cosas más.Sea como sea es importante entender que Powershell depende del CLR.
Si bien el CLR permite realizar esto contra el hardware,para poder usarlo se necesita .NET,el cual está sobre el CLR(pero muy integrado con él).Recordando el ls anterior,que devuelve Files,estos Objetos File están echos en DotNet

También están las Libraries,básicamente permiten añadir sus propios Objects,extendiendo funcionalidad(cada archivo dll es una libreria).Por ejemplo tengo a .net dll.
Se puede añadir cualquier libreria a casi cualquier cosa en informática

			VIDEO 03 VARIABLES + NOTEPROPERTIES + CSV FILES

Una variable en su forma más simple es un lugar en la memoria donde puedo almacenar objetos.Cada variable tendrá un nombre único que la identifique.Siguiendo los ejemplos anteriores puedo almacenar los procesos con un uso de CPU mayor al 20% en una variable:
* Despues mediremos la media y filtraremos por alguna condición.También los ordenaremos.Es por esto que almacenar la primera operación en una variable es una buena idea.

>$expensiveProcesses = Get-Process | where {$_.CPU -gt 20}

TIP: es más eficiente almacenar el Get-Process | {} inicial en una variable que recalcularlo en cada instrucción por la consola.Asi que el uso de variables es una buena idea en varios sentidos

Para almacenar la data en una variable simplemente la asigno a $<varName>.Para leerla usaré la misma sintaxis:
>$expensiveProcesses	<- esto llamará al otro comando,imprimiendolo
>$expensiveProcesses | foreach { $_.CPU } | Measure -Average <- fijate como el foreach está actuando de filter,de echo no funcionaría el Measure sin él.

TIP: fijate que puedo acceder con $person.Name a un objeto que tuviera la propiedad Name(recuerda que serán mayúsculas en C#).

			COMANDO IMPORT-CSV

Este comando Import-Csv toma toda la información de un archivo CSV y la transforma en Objetos(en una tabla de registros donde cada registro es un Object).
TIP: PS también carga XML y JSON
>$students = Import-Csv -Path 'students.csv

NOTA FUNDAMENTAL: un CSV no sabe distinguir entre texto y numeros(no sucede lo mismo con xml o json)(yo creo que en realidad entrega todo como Strings y hay que convertir a int) 	
>$t="123"
>$t + 1 <- me dará el string 1231
>[int]$t +1 <- me dará 124

Con todo esto en mente hay que parsear las columnas Maths y Age:
>$students | foreach { $_.Maths = [int]$_.Maths} 
>$students | foreach { $_.Age = [int]$_.Age} 
Y ya podria sabar la media correctamente:
>$students | foreach { $_.Maths } | Measure -Average -Maximum -Minimum -Sum

			PROPERTIES - NoteProperty

Las properties no son lo único que puedo encontrar en un Object en PS.Hay más cosas,aunque normalmente no son importantes.
Otras,como ScriptProperty,que permite ejecutar un pequeño script al acceder a la property si puede ser importante.
Sabiendo esto,también debo saber que cualquier property está o existe físicamente en DotNet(es decir,que su código ya existia antes de arrancar la Powershell).
Es decir,que no puedo hacer que un File no tenga la propiedad Size o Extension,ya que ese código no es de mi acceso.No puedo remover ni,obviamente,añadir.

IMPORTANTE: sin embargo,si que hay una cosa especial que puedo hacer,y es añadir una NoteProperty a cualquier Object,en cualquier momento, mientras esté corriendo Powershell.

De echo,todas las properties que resultaron de leer el csv con Import-Csv son NoteProperties,ya que no existen en .NET,sólo existen para esa ejecución de la terminal.

Con todo esto en mente,podemos crear otra nueva columna/NoteProperty que sea la resultante de sumar las columnas English y Maths,para despues EXPORTAR ESE CSV, con el comando Export-Csv.Genial

		AÑADIENDO PROPIEDADES A OBJETOS - Add-Member

Primero guardamos un File,que será nuestro csv:
>$file = ls | where { $_.Name -Like "*.csv" }
Añadamos una Columna/NoteProperty "Importance".Para ello voy a usar el comando Add-Member.La sintaxis es Add-Member -InputObject <ObjectName> -MemberType <Type> -Name <Name> -Value <Value>

>Add-Member -InputObject $file -MemberType NoteProperty -Name 'Importance'
*Desafortunadamente tengo que pedir explicitamente esta propiedad:
>$file | ft -Property Name,Lenghth,Importance

╰─ $file | ft -Property Name,Length,Importance

Name         Length Importance
----         ------ ----------
students.csv   2323          0

Obviamente ahora ya puedo cambiarla:
>$file.Importance = 5

>$students | foreach { Add-Member -InputObject $_ -MemberType NoteProperty -Name 'Sum' -Value ($_.Maths + $_.English) } <- ojo con los parentesis,asinto

Ya puedo guardarlo a un .csv:
>$students | Export-Csv 'WithNoteProperty.csv' <- Perfecto

IMPORTANTE: el comando anterior es demasiado largo,no sería mejor que hubiera una forma de reducirlo?.La verdad es que la hay,usando alias.Lo veré en breve.


			VIDEO 04 TYPES + METHODS + CASTING

Tal como ya hemos mencionado el comando para añadir la nueva columna es demasiado largo.¿Como podría acortarlo?.

Uno: Hay un alias para ForEach,es el simbolo del porcentaje:
$students | % { $_.English = [int]$_.English } <- esto resume un poco,si

Dos: No necesito usar -InputObject ,puedo pipear el objeto al comando:
$students | % { $_ | Add-Member

Tres: Dado que siempre que se usa Add-Member,o al menos el 95% de las veces, es para añadir una NoteProperty hay un atajo que creo el equipo de Powershell:
$students | % { $_ | Add-Member -NotePropertyMembers @{Sum=($_.Maths + $_.English)}  }
* puedo traducirlo por añado una NoteProperty que será la resultante de sumar esa operación(y el nombre??) 
TIP: veré más sobre como usar @{} más adelante

				   TYPES FOR OBJECTS

IMPORTANTE:como ya he podido apreciar los Objects son la parte central de Powershell.En Powershell todo Object tiene un Type atado a él.Cada Type describe los miembros que un objeto tendrá.(Estos tipos vienen de .NET).
Por ejemplo,cuando haga un Get-Process recibiré un arreglo de objetos Process.Obviamente,es como una clase,cada instancia tendrá las mismas propiedades/miembros.
NOTA: en Powershell para referirme a un Type tengo que usar square brackets y el type dentro:
[string]
[int]
Fijate que son los primitivos de C#.

TIP: puedo obtener información sobre un type con [type]
>[bool]

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     Boolean                                  System.ValueType

			CASTING DE TYPES

Ya he visto antes como castear a otro tipo.Para hacerlo simplemente paso el [type] antes:
$s = "123" <- es un string
[int]$s <- ahora será el number 123
TIP: el casting convierte un tipo de objeto a otro.
Obviamente,no puedo castear todo,no podría castear un Number a File,pues no tiene sentido

				PROPERTIES IN-DEPTH

Toda Property tiene un Name + un Type,por ejemplo la Property Extension de un File es de tipo String.O la property Name de ese Objeto File también será un String.
Este tipo de Properties no puedo cambiarlas el Type,a diferencia de las NoteProperties,que si puedo darlas el Type que necesite.

			METHODS IN POWERSHELL

Realmente está bastante claro ya que los Objects en PS tendrán properties no customizables y otras que puedo crear.Pero también puedo ejecutar acciones contra los objetos,puedo darles comportamiento.Para ello usaré los methods.
Un method es un bloque de código que puede ejecutar cierta acción al llamarse(start a process,delete a file,..
Hay que tener en cuenta que diferentes tipos de Object tendrán diferentes tipos de métodos disponibles.
TIP:cada mismo tipo de objeto compartirá los mismos métodos(cada File puede hacer lo mismo,cada Process lo mismo,...
Obviamente un método puede tomar argumentos,de echo es bastante normal.

NOTA: Powershell tratará de hacer coincidir los types de los argumentos.A esto se le llama autocasting.Por ejemplo puedo pasarle un File aunque espere un string[]:
>Import-Csv -Path $file <- tratará de pasar el File a String
Powershell es bastante potente a la hora de hacer autocasting,claro que obviamente tiene sus límites

IMPORTANTE: los métodos también devolverán Objects.Sin embargo,no todo método devuelve algo,pero en caso de hacerlo devolverá un Object.Bien.Es hora de ver como se llaman en PS

			CALLING METHODS IN POWERSHELL

Puedo empezar con el método GetType.Todo Objeto en PS tiene acceso a este método,el cual,obviamente nos dice el tipo o clase del Objecto:

╰─ $s="string"

╭─ ♥ 09:33 |          PowerShellSeries
╰─ [string]
IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                                   System.Object

╰─ $s.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     String                                   System.Object

Puedo ver que tanto llamar a [string] como a "hola".GetType()  me devuelve el mismo Objct.

TIP: para saber el nombre programático de un File lo tengo en la property Name:
╰─ $file.GetType()

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     FileInfo                                 System.IO.FileSystemInfo

Asi pues,un File es de tipo FileInfo.

Puedo ejecutar un método por cada iteración,por ejemplo.
>Get-Process | % { $_.GetType() } 

TIP: realmente GetType puede arrojar mucha más información,pero tengo que imprimirla en formato lista y no tabla para ver la que estaba oculta:
> "hola".GetType() | fl

BaseType                   : System.Object
UnderlyingSystemType       : System.String
FullName                   : System.String
AssemblyQualifiedName      : System.String, mscorlib, Version=4.0.0.0, Culture=neutral,
PublicKeyToken=b77a5c561934e089
Namespace                  : System
GUID                       : 296afbff-1b0b-3ff5-9d6c-4e7e599f8b57
IsEnum                     : False

Puedo ver que son muchas y realmente complejas,no son necesarias de momento.

				CHAINING METHODS

También puedo encadenar métodos,por ejemplo GetProperties() me devuelve las propiedades de un Type y getType me devuelve un Type,luego:
╰─ "hola".GetType().GetProperties() | ft

MemberType Name   DeclaringType ReflectedType MetadataToken Module                       PropertyType Attributes CanRead CanWrite
---------- ----   ------------- ------------- ------------- ------                       ------------ ---------- ------- --------
Property Length System.String System.String     385876102 CommonLanguageRuntimeLibrary System.Int32       None    True    False
Property Chars  System.String System.String     385876101 CommonLanguageRuntimeLibrary System.Char        None    True    False


Puedo ver que Length es un Int32 y Chars es un Char

			COMMANDS VS METHODS

Por último debo comprender la diferencia entre comandos y métodos.Por ejemplo,para borrar un objeto puedo usar el comando Remove-Item o el método .Delete():
$obj | Remove-Item <- puedo borrar algo usando el comando ó
$obj.Delete() <- también puedo borrarlo usando el método

TIP: puedo cambiar los permisos a un archivo con takeown( /a /r /f) + ruta.Ejemplo:
>takeown /a /r /f C:Documents <- /a es para que los coga el administrador,pero puedo omitirlo y tomará control el user actual.
Este comando requiere de una consola elevada en permisos.

NOTA: el consejo es que use el comandlet siempre que exista y cuando no exista ya use métodos.Es decir,que los métodos son para cosas más complejas,seguramente tenga que definirlos y desarrollarlos primero.

		EPISODE 5 METHODS WITH PARAMETERS- OVERLOAD OF METHODS

Este video es la parte dos del anterior.Nos acercamos también a una GUI que haremos con botones y todo en PS.
Types: recuerda que cada Object tiene un Type(Class),por ejemplo puede ser de Type Process o File.Según el tipo,tendrá ciertas Properties y Methods disponibles,y puedo agregar NoteProperties también durante la session.

TIP: puedo usar el método GetType en cualquier objeto,es un método sobre el que toda instancia tiene visión:
"hola".GetType() <- fijate que me devolverá el Type el método

IMPORTANTE: y de igual manera que puedo ver las properties de un Type con Type.GetProperties() también puedo ver los métodos con Type.GetMethods()

			PARAMETERS IN METHODS

Si intento mover un file(un Object) con Object.MoveTo() sin usar argumentos veré el siguiente error:

╰─ $file.MoveTo()
No se encuentra ninguna sobrecarga para "MoveTo" y el número de argumentos "0".
En línea: 1 Carácter: 1
+ $file.MoveTo()

NOTA:el argumento además es de tipo string,no sólo tendré que cumplir con el número de argumentos del método,sino con sus tipos.

Lo mismo ocurrirá con String.Replace(a,b).Necesitará dos argumentos o no funcionará:
╰─ "a,b".Replace(',','-');

			FORMAL DESCRIPTIONS OF METHODS

Bien,debe haber una forma de consultar cada método,con sus sobrecargas,número de argumentos,orden de los mismos,..,no?
void Close()
bool WaitForExit(int miliseconds)
void M(string a,int b)
TIP: puedo ver que esto es C#.PowerShell va a seguir su sintaxis.Dado que C# está escrito sobre .NET y PowerShell también,se compartirá el lenguaje.Bien.

string A { get; } <- getter,puedo leer la info(con un setter la cambiaré)

			VIEWING MEMBERS

Con el método Get-Member puedo listar todos los Members de un Object(tanto las Properties como los Métodos).Es un método fantástico para ver todo lo que tiene un Objeto:
>Get-Process | Get-Member


   TypeName: System.Diagnostics.Process

   Name                       MemberType     Definition
   ----                       ----------     ----------
   Handles                    AliasProperty  Handles = Handlecount
   Name                       AliasProperty  Name = ProcessName
   NPM                        AliasProperty  NPM = NonpagedSystemMemorySize64
   PM                         AliasProperty  PM = PagedMemorySize64
   SI                         AliasProperty  SI = SessionId
   VM                         AliasProperty  VM = VirtualMemorySize64
   WS                         AliasProperty  WS = WorkingSet64
   Disposed                   Event          System.EventHandler Disposed(System.Object, Sy...
   ErrorDataReceived          Event          System.Diagnostics.DataReceivedEventHandler Er...
   Exited                     Event          System.EventHandler Exited(System.Object, Syst...
   OutputDataReceived         Event          System.Diagnostics.DataReceivedEventHandler Ou...
   BeginErrorReadLine         Method         void BeginErrorReadLine()
   BeginOutputReadLine        Method         void BeginOutputReadLine()
   CancelErrorRead            Method         void CancelErrorRead()
   CancelOutputRead           Method         void CancelOutputRead()
   Close                      Method         void Close()
   CloseMainWindow            Method         bool CloseMainWindow()

Puedo ver en la Propiedad MemberType el tipo de cada Member,si es un Method o AliasProperty o Property,Event,etc...
IMPORTANTE: en algunas Properties veré tanto si sólo las puedo leer como si las puedo modificar:
MaxWorkingSet              Property       System.IntPtr MaxWorkingSet {get;set;}
MinWorkingSet              Property       System.IntPtr MinWorkingSet {get;set;}
Modules                    Property       System.Diagnostics.ProcessModuleCollection Mod...
NonpagedSystemMemorySize   Property       int NonpagedSystemMemorySize {get;}
NonpagedSystemMemorySize64 Property       long NonpagedSystemMemorySize64 {get;}

Las que tenga acceso al getter y setter veré {get;set;}.Perfecto.

				SOBRECARGA DE MÉTODOS

Bien,si me fijo en este método,veré que tiene varias formas posibles de llamarlo:
WaitForExit                Method         bool WaitForExit(int milliseconds), void WaitForExit()
WaitForInputIdle           Method         bool WaitForInputIdle(int milliseconds), bool WaitForInputIdle()
A esto se le llama sobrecarga de métodos.Realmente son varios métodos,todos con el mismo nombre,y según el número y orden se llamará a uno u otro.

TIP: si llamo aun método por referencia PS me dirá su sobrecarga:
╰─ "a".Replace

OverloadDefinitions
-------------------
string Replace(char oldChar, char newChar)
string Replace(string oldValue, string newValue)

Esto es genial,ya que antes de llamarlo puedo consultar rápidamente su sobrecarga.
TIP: recuerda que where es como find,devolverá las iteracciones que se resuelvan a true.

		EXPERIMENTING WITH TYPES

Ya sé que ls me muestra todos los files y directories,pero si quisiera puedo listar sólo los directorios:
>ls -Directory
Bien,obviamentes esto es lo que haré cuando quiera ver sólo los directorios,usar la flag,pero que tal si lo hacemos filtrando los Types,ya que estamos viendo Types?:

╰─ ls | % { $_.GetType() }

IsPublic IsSerial Name                                     BaseType
-------- -------- ----                                     --------
True     True     DirectoryInfo                            System.IO.FileSystemInfo
True     True     FileInfo                                 System.IO.FileSystemInfo
True     True     FileInfo                                 System.IO.FileSystemInfo
True     True     FileInfo                                 System.IO.FileSystemInfo
True     True     FileInfo                                 System.IO.FileSystemInfo

Con esto en mente podría listar los directorios asi:
╰─ ls | ? { $_.GetType().Name -eq "DirectoryInfo" }

	
